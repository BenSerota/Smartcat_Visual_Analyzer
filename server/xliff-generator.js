/**
 * XLIFF Generator
 * Creates XLIFF files with high-resolution visual segmentation metadata
 */

class XLIFFGenerator {
  constructor() {
    this.namespace = 'urn:oasis:names:tc:xliff:document:1.2'
  }

  /**
   * Generate XLIFF content from visual segments
   * @param {Array} segments - Array of visual segments
   * @param {string} fileName - Original file name
   * @param {string} sourceLanguage - Source language code (default: en)
   * @param {string} targetLanguage - Target language code (default: es)
   * @returns {string} XLIFF XML content
   */
  generateXLIFF(segments, fileName, sourceLanguage = 'en', targetLanguage = 'es') {
    const fileId = this.generateFileId(fileName)
    const date = new Date().toISOString()
    
    const header = this.generateHeader(fileName, sourceLanguage, targetLanguage, date)
    const body = this.generateBody(segments, fileId)
    const footer = this.generateFooter()
    
    return `<?xml version="1.0" encoding="UTF-8"?>
<xliff version="1.2" xmlns="${this.namespace}">
${header}
${body}
${footer}
</xliff>`
  }

  /**
   * Generate XLIFF header
   * @param {string} fileName - File name
   * @param {string} sourceLanguage - Source language
   * @param {string} targetLanguage - Target language
   * @param {string} date - Creation date
   * @returns {string} Header XML
   */
  generateHeader(fileName, sourceLanguage, targetLanguage, date) {
    return `  <file original="${this.escapeXml(fileName)}" 
        source-language="${sourceLanguage}" 
        target-language="${targetLanguage}" 
        datatype="plaintext" 
        date="${date}">
    <header>
      <tool tool-id="visual-segmenter" tool-name="Visual Segmenter" tool-version="1.0.0"/>
      <note>Generated by Visual Segmenter - AI-powered PowerPoint segmentation using visual context analysis</note>
    </header>`
  }

  /**
   * Generate XLIFF body with segments
   * @param {Array} segments - Array of visual segments
   * @param {string} fileId - File ID
   * @returns {string} Body XML
   */
  generateBody(segments, fileId) {
    const transUnits = segments.map((segment, index) => 
      this.generateTransUnit(segment, index + 1, fileId)
    ).join('\n')

    return `    <body>
${transUnits}
    </body>`
  }

  /**
   * Generate a translation unit for a segment
   * @param {Object} segment - Visual segment
   * @param {number} index - Segment index
   * @param {string} fileId - File ID
   * @returns {string} Translation unit XML
   */
  generateTransUnit(segment, index, fileId) {
    const id = `${fileId}_seg_${index}`
    const source = this.escapeXml(segment.text)
    const target = this.escapeXml(segment.translation || segment.text)
    
    // Generate visual context metadata
    const visualMetadata = this.generateVisualMetadata(segment)
    
    return `      <trans-unit id="${id}" resname="visual_segment_${index}">
        <source>${source}</source>
        <target state="new">${target}</target>
        <note category="visual_context" priority="1">${visualMetadata}</note>
        <note category="coordinates">${JSON.stringify(segment.coordinates)}</note>
        <note category="confidence">${segment.confidence}</note>
        <note category="slide_id">${segment.slideId}</note>
        <note category="text_element_id">${segment.textElementId}</note>
        <note category="visual_context_id">${segment.visualContextId}</note>
        ${segment.topic ? `<note category="topic">${this.escapeXml(segment.topic)}</note>` : ''}
        ${segment.semanticContext ? `<note category="semantic_context">${this.escapeXml(segment.semanticContext)}</note>` : ''}
        ${segment.contentElements ? `<note category="content_elements">${this.escapeXml(JSON.stringify(segment.contentElements))}</note>` : ''}
        ${segment.notes ? `<note category="analysis_notes">${this.escapeXml(segment.notes)}</note>` : ''}
      </trans-unit>`
  }

  /**
   * Generate visual context metadata
   * @param {Object} segment - Visual segment
   * @returns {string} Visual metadata JSON
   */
  generateVisualMetadata(segment) {
    const metadata = {
      visualContext: segment.visualContext,
      boundingBox: segment.coordinates,
      slideId: segment.slideId,
      textElementId: segment.textElementId,
      visualContextId: segment.visualContextId,
      confidence: segment.confidence,
      isCombined: segment.isCombined || false,
      isMerged: segment.isMerged || false,
      elementCount: segment.elementCount || 1,
      originalSegments: segment.originalSegments || [],
      parentContextId: segment.parentContextId || null,
      // Enhanced semantic context
      topic: segment.topic,
      semanticContext: segment.semanticContext,
      contentElements: segment.contentElements
    }
    
    return this.escapeXml(JSON.stringify(metadata, null, 2))
  }

  /**
   * Generate XLIFF footer
   * @returns {string} Footer XML
   */
  generateFooter() {
    return `  </file>`
  }

  /**
   * Generate a unique file ID from file name
   * @param {string} fileName - File name
   * @returns {string} File ID
   */
  generateFileId(fileName) {
    return fileName
      .replace(/[^a-zA-Z0-9]/g, '_')
      .replace(/_+/g, '_')
      .replace(/^_|_$/g, '')
      .toLowerCase()
  }

  /**
   * Escape XML special characters
   * @param {string} text - Text to escape
   * @returns {string} Escaped text
   */
  escapeXml(text) {
    if (typeof text !== 'string') {
      text = String(text)
    }
    
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;')
  }

  /**
   * Generate XLIFF filename
   * @param {string} originalFileName - Original file name
   * @param {string} targetLanguage - Target language
   * @returns {string} XLIFF filename
   */
  generateXLIFFFileName(originalFileName, targetLanguage = 'es') {
    const baseName = originalFileName.replace(/\.[^/.]+$/, '')
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19)
    return `${baseName}_visual_segmented_${targetLanguage}_${timestamp}.xlf`
  }

  /**
   * Validate XLIFF content
   * @param {string} xliffContent - XLIFF content
   * @returns {Object} Validation result
   */
  validateXLIFF(xliffContent) {
    const errors = []
    const warnings = []

    // Basic XML structure validation
    if (!xliffContent.includes('<?xml version="1.0"')) {
      errors.push('Missing XML declaration')
    }

    if (!xliffContent.includes('<xliff version="1.2"')) {
      errors.push('Missing XLIFF root element')
    }

    if (!xliffContent.includes('<file')) {
      errors.push('Missing file element')
    }

    if (!xliffContent.includes('<body')) {
      errors.push('Missing body element')
    }

    if (!xliffContent.includes('<trans-unit')) {
      warnings.push('No translation units found')
    }

    // Count translation units
    const transUnitMatches = xliffContent.match(/<trans-unit/g)
    const transUnitCount = transUnitMatches ? transUnitMatches.length : 0

    return {
      isValid: errors.length === 0,
      errors,
      warnings,
      transUnitCount,
      fileSize: xliffContent.length
    }
  }
}

module.exports = XLIFFGenerator
